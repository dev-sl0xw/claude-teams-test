# 캐싱 전략: ElastiCache, DAX, CloudFront

## 왜 이것이 중요한가? (질문)

> 읽기 전에 스스로에게 물어보세요: 데이터베이스 조회가 100ms 걸리는데, 같은 데이터를 1분 내에 1,000명이 요청한다면? 1,000번 DB에 쿼리하는 것과, 한 번 쿼리한 결과를 캐시에서 제공하는 것의 차이를 상상해보세요.

## 핵심 개념

### 왜 캐싱이 성능 효율성의 핵심인가?

캐싱은 **이전에 계산/조회한 결과를 저장해두고 재사용**하는 기술입니다. 가장 적은 노력으로 가장 큰 성능 향상을 얻을 수 있는 방법입니다.

**캐싱의 효과:**
- 데이터베이스 부하 감소 (읽기 요청의 80%를 캐시에서 처리)
- 응답 지연시간 단축 (DB: 수 ms ~ 수십 ms -> 캐시: sub-ms)
- 비용 절감 (DB 스케일업 대신 캐시 활용)

**캐싱의 트레이드오프:**

> 질문: 캐싱을 사용하면 "무엇을 포기"하게 되나요?

- **일관성 (Consistency)**: 캐시 데이터가 원본과 다를 수 있음 (Stale Data)
- **복잡성**: 캐시 무효화(Invalidation) 전략이 필요
- **비용**: 캐시 인프라 자체의 비용

> "컴퓨터 과학에서 어려운 것은 딱 두 가지: 캐시 무효화와 이름 짓기" - Phil Karlton

### ElastiCache - 인메모리 캐시 서비스

**무엇인가?** Redis 또는 Memcached를 관리형으로 제공하는 서비스.

**왜 직접 Redis를 설치하지 않고 ElastiCache를 사용하는가?**
- 자동 패치, 백업, 모니터링
- Multi-AZ 자동 장애 조치 (Redis)
- 클러스터 모드로 수평 확장
- VPC 내 보안 그룹으로 접근 제어

#### Redis vs Memcached (SAA 시험 핵심)

| 기능 | Redis | Memcached |
|------|-------|-----------|
| 데이터 구조 | String, Hash, List, Set, Sorted Set 등 | String만 |
| 영속성 | 지원 (스냅샷, AOF) | 미지원 |
| 복제 | 지원 (Read Replica) | 미지원 |
| Multi-AZ | 자동 장애 조치 지원 | 미지원 |
| 클러스터 모드 | 지원 (샤딩) | 지원 (샤딩) |
| Pub/Sub | 지원 | 미지원 |
| Lua 스크립트 | 지원 | 미지원 |
| 백업/복원 | 지원 | 미지원 |
| 멀티스레드 | 단일 스레드 (6.x부터 I/O 스레드) | 멀티스레드 |

> 질문: Redis가 거의 모든 면에서 우월해 보이는데, 언제 Memcached를 선택해야 할까요?
> 힌트: 단순한 키-값 캐시에 멀티스레드 처리가 필요할 때

#### 캐싱 전략 패턴

**1. Lazy Loading (Cache-Aside)**
```
요청 → 캐시 확인 → [캐시 히트] → 캐시에서 반환
                  → [캐시 미스] → DB 조회 → 캐시에 저장 → 반환
```
- **장점**: 요청된 데이터만 캐시 (메모리 효율적)
- **단점**: 첫 요청은 항상 느림 (캐시 미스), Stale Data 가능성

**2. Write-Through**
```
쓰기 요청 → DB에 저장 + 캐시에 저장 → 완료
읽기 요청 → 캐시에서 바로 반환 (항상 히트)
```
- **장점**: 캐시 데이터가 항상 최신
- **단점**: 읽히지 않는 데이터도 캐시에 저장 (메모리 낭비)

**3. Write-Behind (Write-Back)**
```
쓰기 요청 → 캐시에만 저장 → 비동기로 DB에 일괄 저장
```
- **장점**: 쓰기 성능 극대화
- **단점**: 캐시 장애 시 데이터 손실 위험

**권장 조합: Lazy Loading + TTL 설정**
```
캐시 확인 → [히트 & TTL 유효] → 반환
           → [미스 또는 TTL 만료] → DB 조회 → 캐시 갱신 (새 TTL) → 반환
```

### DAX (DynamoDB Accelerator)

**무엇인가?** DynamoDB 전용 인메모리 캐시. DynamoDB API와 완전 호환됩니다.

**왜 ElastiCache 대신 DAX를 사용하는가?**
- DynamoDB 클라이언트 코드를 거의 변경하지 않아도 됨
- 읽기 지연시간: 밀리초 -> **마이크로초** (최대 10배 향상)
- Write-Through 캐싱이 자동 적용
- DynamoDB와 동일한 API 사용 (엔드포인트만 변경)

**DAX vs ElastiCache for DynamoDB**

| 구분 | DAX | ElastiCache |
|------|-----|-------------|
| 코드 변경 | 최소 (엔드포인트만) | 캐싱 로직 직접 구현 |
| 대상 | DynamoDB 전용 | 모든 데이터 소스 |
| 캐싱 전략 | 자동 (Write-Through) | 직접 구현 |
| 복잡한 캐싱 로직 | 불가 | 가능 |
| 비용 | 노드 기반 과금 | 노드 기반 과금 |

> 질문: DynamoDB에 대해 DAX가 항상 최선의 선택일까요? "쓰기 집중" 워크로드에서 DAX가 도움이 될까요?

### CloudFront - CDN(Content Delivery Network)

**무엇인가?** 전 세계 450+ 엣지 로케이션에서 콘텐츠를 캐싱하여 사용자에게 가장 가까운 위치에서 제공합니다.

**왜 CloudFront가 필요한가?**
- 서울 리전의 서버에서 미국 사용자에게 응답하면 **200ms+ 지연시간**
- CloudFront를 사용하면 미국의 엣지 로케이션에서 응답 -> **20ms 이하**

**CloudFront 캐싱 계층**

```
사용자 → [엣지 로케이션 캐시] → [리전 엣지 캐시] → [오리진(S3/ALB/EC2)]
         (가장 가까운 POP)      (리전 레벨 캐시)     (원본 서버)
```

**CloudFront 캐시 정책 (Cache Policy)**

| 설정 | 설명 | 주의사항 |
|------|------|----------|
| **TTL** | 캐시 유지 시간 | 너무 길면 Stale, 너무 짧으면 캐시 효과 감소 |
| **Cache Key** | 캐시를 구분하는 기준 | 헤더/쿼리스트링/쿠키 포함 시 캐시 적중률 감소 |
| **Origin Request Policy** | 오리진에 전달할 정보 | Cache Key와 분리하여 불필요한 캐시 분할 방지 |

**OAC (Origin Access Control) - SAA 시험 빈출**

> 질문: S3 버킷을 CloudFront 뒤에 두었는데, 사용자가 S3 URL로 직접 접근하면 어떻게 되나요?

OAC는 CloudFront를 통해서만 S3에 접근할 수 있도록 제한합니다:
- S3 버킷의 퍼블릭 액세스를 완전히 차단
- CloudFront 배포에만 접근 권한 부여
- 이전 방식인 OAI(Origin Access Identity)보다 보안이 강화됨

### 전체 캐싱 아키텍처 예시

```
사용자 → CloudFront (정적 콘텐츠 캐시)
           ↓
         API Gateway → Lambda → ElastiCache (Redis)
                                      ↓ (캐시 미스)
                                   RDS / DynamoDB (DAX)
```

## 잠깐, 그런데... (흔한 오해)

### 오해 1: "캐시를 넣으면 모든 것이 빨라진다"
**쓰기 집중** 워크로드에서는 캐시가 오히려 오버헤드가 됩니다. 캐시는 **읽기 비율이 높고 동일한 데이터가 반복 요청**되는 경우에 효과적입니다.

### 오해 2: "CloudFront는 정적 콘텐츠에만 사용한다"
CloudFront는 **동적 콘텐츠**(API 응답)도 가속할 수 있습니다. 캐시하지 않더라도 AWS 백본 네트워크를 통한 연결 최적화로 지연시간이 줄어듭니다.

### 오해 3: "Redis가 Memcached보다 항상 좋다"
단순 키-값 캐시에 **멀티스레드 처리**가 필요하다면 Memcached가 더 나은 선택일 수 있습니다. 또한 Memcached는 Redis보다 **메모리 오버헤드가 적습니다**.

### 오해 4: "캐시 무효화는 TTL만 설정하면 된다"
TTL 기반 만료만으로는 **중요한 데이터 변경을 즉시 반영할 수 없습니다**. CloudFront의 경우 Invalidation API로 즉시 캐시를 무효화할 수 있지만, 비용이 발생합니다.

## 핸즈온 연결

> 이 개념은 [Lab 02 - ElastiCache]와 [Lab 03 - CloudFront CDN]에서 구현됩니다.
>
> - Lab 02에서 ElastiCache Redis 클러스터를 VPC 내에 구성하고, 서브넷 그룹과 보안 그룹을 설정합니다.
> - Lab 03에서 CloudFront + S3 오리진을 구성하고, OAC로 보안을 강화하며, 캐시 정책을 설정합니다.

## SAA 시험 핵심 포인트

- ElastiCache Redis vs Memcached: 영속성, 복제, Multi-AZ가 필요하면 Redis
- Redis 클러스터 모드: 샤딩으로 수평 확장, 최대 500개 노드
- DAX: DynamoDB 전용, 코드 변경 최소, 마이크로초 지연시간
- CloudFront OAC: OAI의 후속, S3 오리진 접근을 CloudFront로만 제한
- CloudFront 캐시 키: 불필요한 헤더/쿠키를 캐시 키에 포함하면 적중률 급감
- Lambda@Edge: CloudFront 이벤트에서 Lambda 실행 (뷰어 요청/응답, 오리진 요청/응답)
- CloudFront Functions: Lambda@Edge보다 가볍고 빠름, 간단한 헤더 조작에 적합
- 캐싱 전략: Lazy Loading + TTL 조합이 가장 일반적이고 안전

## 관련 Pillar

- **비용 최적화**: 캐시로 DB 읽기를 줄여 비용 절감, 하지만 캐시 자체의 비용도 고려
- **안정성**: Redis Multi-AZ로 캐시 가용성 확보, 캐시 장애 시 DB로 폴백
- **보안**: ElastiCache는 VPC 내 배치, 전송 중 암호화(TLS), 인증(AUTH) 지원
- **운영 우수성**: CloudWatch로 캐시 히트율, 메모리 사용량, 연결 수 모니터링
